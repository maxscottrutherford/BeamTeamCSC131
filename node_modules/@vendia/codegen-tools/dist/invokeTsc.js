import path from 'path';
import os from 'os';
import fs from 'fs';
import { spawn } from 'cross-spawn';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// "forked" from https://github.com/Offirmo/offirmo-monorepo--2021-legacy/tree/master/stack--2021/4-tools/node-typescript-compiler
// and converted to typescript, want more control over how we resolve tsc executable
// Keep the LIB stuff, maybe we'll make this a package one day (with attribution for original author)
const LIB = 'node-tsc';
const EXECUTABLE = 'tsc';
const spawn_options = {
    env: process.env,
};
export const invokeTsc = (tscOptions, files, options) => {
    tscOptions = tscOptions || {};
    files = files || [];
    options = options || {};
    options.verbose = Boolean(options.verbose);
    return new Promise((resolve, reject) => {
        let stdout = '';
        let stderr = '';
        let already_failed = false;
        function on_failure(reason, err) {
            if (already_failed && !options.verbose)
                return;
            stdout = stdout.trim();
            stderr = stderr.trim();
            const reason_from_stdout = (() => {
                const src = stderr || stdout;
                const first_line = src.split('\n')[0];
                if (first_line && first_line.toLowerCase().includes('error'))
                    return first_line;
                return null;
            })();
            err = err || new Error(`${reason_from_stdout || reason}`);
            // @ts-ignore
            err.stdout = stdout;
            // @ts-ignore
            err.stderr = stderr;
            // @ts-ignore
            err.reason = reason;
            if (options.verbose) {
                console.error(`[${LIB}] ✖ Failure during tsc invocation: ${reason}`);
                console.error(err);
            }
            err.message = `[${LIB}@dir:${path.parse(process.cwd()).base}] ${err.message}`;
            reject(err);
            already_failed = true;
        }
        try {
            const tsc_options_as_array = Object.entries(tscOptions).flatMap(([key, value]) => {
                if (value === false)
                    return [];
                if (value === true)
                    return [`--${key}`];
                if (Array.isArray(value))
                    value = value.join(',');
                return [`--${key}`, value];
            });
            // TODO: remove any type
            const spawn_params = tsc_options_as_array.concat(files);
            // not returning due to complex "callback style" async code
            find_tsc(options)
                .then((tsc_executable_absolute_path) => {
                if (options.verbose)
                    console.log(`[${LIB}] ✔ found a typescript compiler at this location: "${tsc_executable_absolute_path}"`);
                if (options.verbose)
                    console.log(`[${LIB}] ► now spawning the compilation command: "${[tsc_executable_absolute_path, ...spawn_params].join(' ')}"...\n`);
                const spawn_instance = spawn(tsc_executable_absolute_path, spawn_params, spawn_options);
                // listen to events
                spawn_instance.on('error', (err) => {
                    on_failure('Spawn: got event "err"', err);
                });
                spawn_instance.on('disconnect', () => {
                    console.log(`[${LIB}] Spawn: got event "disconnect"`);
                });
                spawn_instance.on('exit', (code, signal) => {
                    if (code === 0)
                        resolve(stdout);
                    else
                        on_failure(`Spawn: got event "exit" with error code "${code}" & signal "${signal}"!`);
                });
                spawn_instance.on('close', (code, signal) => {
                    if (code === 0)
                        resolve(stdout);
                    else
                        on_failure(`Spawn: got event "close" with error code "${code}" & signal "${signal}"`);
                });
                // for debug purpose only
                spawn_instance.stdin.on('data', (data) => {
                    console.log(`[${LIB}] got stdin event "data": "${data}"`);
                });
                // mandatory for correct error detection
                spawn_instance.stdin.on('error', (err) => {
                    on_failure('got stdin event "error"', err);
                });
                spawn_instance.stdout.on('data', (data) => {
                    typeof data == 'string' &&
                        data?.split('\n').forEach((line) => {
                            if (!line.length)
                                return; // convenience for more compact output
                            if (line.slice(-35) === 'Starting incremental compilation...')
                                console.log('\n************************************');
                            console.log(EXECUTABLE + '> ' + line);
                        });
                    stdout += data;
                });
                // mandatory for correct error detection
                spawn_instance.stdout.on('error', (err) => {
                    on_failure('got stdout event "error"', err);
                });
                spawn_instance.stderr.on('data', (data) => {
                    typeof data === 'string' &&
                        data?.split('\n').forEach((line) => console.log(EXECUTABLE + '! ' + line));
                    stderr += data;
                });
                // mandatory for correct error detection
                spawn_instance.stderr.on('error', (err) => {
                    on_failure('got stderr event "error"', err);
                });
            })
                .catch((err) => on_failure('final catch', err)); // ugly but due to complex "callback style" async code
        }
        catch (err) {
            on_failure(`unexpected global catch`, err);
        }
    }).then((stdout) => {
        if (options.verbose)
            console.log(`[${LIB}] ✔ executed successfully.`);
        return stdout;
    });
};
function find_tsc({ verbose = false, dotVendiaClientPath }) {
    function log(...args) {
        if (verbose)
            console.log(`[${LIB}]`, ...args);
    }
    log('__dirname:', __dirname);
    log('process.cwd():', process.cwd());
    log('dotVendiaClientPath:', dotVendiaClientPath);
    // ----- Vendia-specific attempts ------
    // look for the typescript compiler we ship with codegen-tools
    // node_modules/@vendia/codegen-tools/node_modules/typescript/bin/tsc
    const node_modules_path = path.join(dotVendiaClientPath, '..');
    const candidate_from_codegen_tools = path.join(node_modules_path, '@vendia', 'codegen-tools', 'node_modules', 'typescript', 'bin', EXECUTABLE);
    log('node_modules_path:', node_modules_path);
    log('candidate_from_codegen_tools:', candidate_from_codegen_tools);
    // Use the root path we're using to create .vendia-client path to discover their top-level node_modules folder
    const candidate_using_dot_vendia_client_path = path.join(node_modules_path, 'typescript', 'bin', EXECUTABLE);
    log('candidate_using_dot_vendia_client_path:', candidate_using_dot_vendia_client_path);
    // Fixing pnpm
    // precise walk back from node_modules/.pnpm/@vendia+codegen-tools@0.10.1/node_modules/@vendia/codegen-tools/dist to typescript/bin/tsc
    const alt_candidate_from_sibling_module = path.join(__dirname, '..', '..', '..', 'typescript', 'bin', EXECUTABLE);
    log('alt_candidate_from_sibling_module:', alt_candidate_from_sibling_module);
    // ----- Original library attempts -----
    // obvious candidate from sibling module,
    // but won't work if symlinked, with npm link for ex. or with npm-pkgr
    const candidate_from_sibling_module = path.join(__dirname, '..', 'typescript', 'bin', EXECUTABLE);
    // second try: should work even if module is symlinked
    const candidate_from_caller_node_module = path.join(process.cwd(), 'node_modules', 'typescript', 'bin', EXECUTABLE);
    // 3rd
    let candidate_from_require = '';
    try {
        candidate_from_require = path.dirname(require.resolve('typescript'));
        candidate_from_require = path.join(candidate_from_require, '..', 'bin', EXECUTABLE);
    }
    catch (err) {
        /* not found, ignore */
    }
    // last try: defaulting to an eventual global typescript module
    // (using nvm on OSX)
    const candidate_from_global = path.join(os.homedir(), '.nvm', 'versions', 'node', process.version, 'bin', EXECUTABLE);
    // TODO other OSes?
    return candidate_if_exists(candidate_from_codegen_tools)
        .catch(() => candidate_if_exists(candidate_using_dot_vendia_client_path))
        .catch(() => candidate_if_exists(alt_candidate_from_sibling_module))
        .catch(() => candidate_if_exists(candidate_from_sibling_module))
        .catch(() => candidate_if_exists(candidate_from_caller_node_module))
        .catch(() => candidate_if_exists(candidate_from_require))
        .catch(() => candidate_if_exists(candidate_from_global))
        .catch(() => {
        console.error(`❌ Couldn’t find a typescript compiler ("${EXECUTABLE}") in any expected locations. Unsuccessfully tested locations, by priority:
- ${candidate_from_codegen_tools} ❌ not found
- ${candidate_using_dot_vendia_client_path} ❌ not found
- ${alt_candidate_from_sibling_module} ❌ not found
- ${candidate_from_sibling_module} ❌ not found
- ${candidate_from_caller_node_module} ❌ not found
- ${candidate_from_require} (from require('typescript')) ❌ not found
- ${candidate_from_global} ❌ not found
`);
        throw new Error(`Couldn’t find the "${EXECUTABLE}" typescript compiler in any expected locations!`);
    });
}
function candidate_if_exists(candidate) {
    return new Promise((resolve, reject) => {
        if (!candidate) {
            reject(`Couldn’t find candidate typescript compiler!`);
            return;
        }
        fs.access(candidate, fs.constants.X_OK, (err) => {
            if (err)
                reject(`Couldn’t find candidate typescript compiler "${candidate}"!`);
            else
                resolve(candidate);
        });
    });
}
