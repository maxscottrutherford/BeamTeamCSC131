{"ast":null,"code":"import { v4 as uuid4 } from '@lukeed/uuid';\nimport { print } from 'graphql';\nimport { createClient } from 'graphql-ws';\nimport WebSocket from 'isomorphic-ws';\n// Extends core client with subscriptions\nexport const createSubscriptionClient = function (options, {\n  _logger,\n  _onAuthStateChange\n}) {\n  const {\n    apiKey,\n    getCredentials,\n    onError\n  } = options;\n  let subscriptionClient;\n  const _createSubscriptionClient = () => {\n    _logger('Creating subscription client...');\n    let websocketUrl = options.websocketUrl ?? '';\n    // Just in case user adds trailing slash\n    if (websocketUrl.endsWith('/')) {\n      websocketUrl = websocketUrl.slice(0, -1);\n    }\n    const subClientOptions = {\n      url: websocketUrl,\n      webSocketImpl: WebSocket\n    };\n    // If user provides getCredentials, pass that to connectionParams\n    if (typeof getCredentials === 'function') {\n      // This will be called for every connection_init event and the payload will contain { token: <user's jwt> OR apiKey: <apiKey> }\n      subClientOptions.connectionParams = async () => {\n        const credentials = await getCredentials();\n        return {\n          ...credentials\n        };\n      };\n    } else if (apiKey) {\n      // If they initialized client with apiKey just pass in static object\n      subClientOptions.connectionParams = {\n        apiKey\n      };\n    }\n    const subClient = createClient(subClientOptions);\n    subClient.on('connecting', () => _logger('subscriptionClient connecting...'));\n    subClient.on('connected', () => _logger('subscriptionClient connected!'));\n    subClient.on('closed', () => _logger('subscriptionClient ---disconnected!!!---'));\n    return subClient;\n  };\n  /*\n    Because we may not have the observable's raw unsubscribe function available to return to user\n    when they create a subscribtion, we return a proxy \"wrapper\" function that will look-up the real unsub func from connectedUnsubscribeMap when called.\n  */\n  const connectedUnsubscribeMap = new Map();\n  const _subscribe = ({\n    query,\n    variables\n  }, handler) => {\n    const queryAsString = print(query);\n    _logger(`subscriptionClient creating subscription ${queryAsString}`);\n    if (options.websocketUrl === undefined) {\n      throw new Error('Please initialize @vendia/client with the websocketUrl option in order to use subscriptions.');\n    }\n    // Don't create a socket connection until user tries to use subscription\n    if (subscriptionClient === undefined) {\n      subscriptionClient = _createSubscriptionClient();\n    }\n    const unsubscribe = subscriptionClient.subscribe({\n      query: queryAsString,\n      variables\n    }, {\n      next: handler,\n      error: error => {\n        _logger('subscriptionClient error:', JSON.stringify(error, null, 2));\n        if (typeof onError === 'function') {\n          onError(error);\n        }\n      },\n      complete: () => {\n        _logger('subscriptionClient complete fired');\n      }\n    });\n    const observableId = uuid4();\n    connectedUnsubscribeMap.set(observableId, unsubscribe);\n    return createUnsubscribeWrapperFunc(observableId);\n  };\n  const createUnsubscribeWrapperFunc = observableId => {\n    return () => {\n      const unsubFunc = connectedUnsubscribeMap.get(observableId);\n      if (unsubFunc) {\n        _logger('Unsubscribing.');\n        unsubFunc();\n        return;\n      }\n      _logger('Tried to unsubscribe, but subscription does not exist. This probably means unsubscribe has already been called for this subscription.');\n    };\n  };\n  return {\n    _subscribe\n  };\n};","map":{"version":3,"names":["v4","uuid4","print","createClient","WebSocket","createSubscriptionClient","options","_logger","_onAuthStateChange","apiKey","getCredentials","onError","subscriptionClient","_createSubscriptionClient","websocketUrl","endsWith","slice","subClientOptions","url","webSocketImpl","connectionParams","credentials","subClient","on","connectedUnsubscribeMap","Map","_subscribe","query","variables","handler","queryAsString","undefined","Error","unsubscribe","subscribe","next","error","JSON","stringify","complete","observableId","set","createUnsubscribeWrapperFunc","unsubFunc","get"],"sources":["/Users/maxrutherford/Desktop/SacState/FA23/CSC131/beamteam-csc131/node_modules/.vendia-client/esm/create-subscription-client.js"],"sourcesContent":["import { v4 as uuid4 } from '@lukeed/uuid';\nimport { print } from 'graphql';\nimport { createClient } from 'graphql-ws';\nimport WebSocket from 'isomorphic-ws';\n// Extends core client with subscriptions\nexport const createSubscriptionClient = function (options, { _logger, _onAuthStateChange, }) {\n    const { apiKey, getCredentials, onError } = options;\n    let subscriptionClient;\n    const _createSubscriptionClient = () => {\n        _logger('Creating subscription client...');\n        let websocketUrl = options.websocketUrl ?? '';\n        // Just in case user adds trailing slash\n        if (websocketUrl.endsWith('/')) {\n            websocketUrl = websocketUrl.slice(0, -1);\n        }\n        const subClientOptions = {\n            url: websocketUrl,\n            webSocketImpl: WebSocket,\n        };\n        // If user provides getCredentials, pass that to connectionParams\n        if (typeof getCredentials === 'function') {\n            // This will be called for every connection_init event and the payload will contain { token: <user's jwt> OR apiKey: <apiKey> }\n            subClientOptions.connectionParams = async () => {\n                const credentials = await getCredentials();\n                return {\n                    ...credentials,\n                };\n            };\n        }\n        else if (apiKey) {\n            // If they initialized client with apiKey just pass in static object\n            subClientOptions.connectionParams = { apiKey };\n        }\n        const subClient = createClient(subClientOptions);\n        subClient.on('connecting', () => _logger('subscriptionClient connecting...'));\n        subClient.on('connected', () => _logger('subscriptionClient connected!'));\n        subClient.on('closed', () => _logger('subscriptionClient ---disconnected!!!---'));\n        return subClient;\n    };\n    /*\n      Because we may not have the observable's raw unsubscribe function available to return to user\n      when they create a subscribtion, we return a proxy \"wrapper\" function that will look-up the real unsub func from connectedUnsubscribeMap when called.\n    */\n    const connectedUnsubscribeMap = new Map();\n    const _subscribe = ({ query, variables }, handler) => {\n        const queryAsString = print(query);\n        _logger(`subscriptionClient creating subscription ${queryAsString}`);\n        if (options.websocketUrl === undefined) {\n            throw new Error('Please initialize @vendia/client with the websocketUrl option in order to use subscriptions.');\n        }\n        // Don't create a socket connection until user tries to use subscription\n        if (subscriptionClient === undefined) {\n            subscriptionClient = _createSubscriptionClient();\n        }\n        const unsubscribe = subscriptionClient.subscribe({ query: queryAsString, variables }, {\n            next: handler,\n            error: (error) => {\n                _logger('subscriptionClient error:', JSON.stringify(error, null, 2));\n                if (typeof onError === 'function') {\n                    onError(error);\n                }\n            },\n            complete: () => {\n                _logger('subscriptionClient complete fired');\n            },\n        });\n        const observableId = uuid4();\n        connectedUnsubscribeMap.set(observableId, unsubscribe);\n        return createUnsubscribeWrapperFunc(observableId);\n    };\n    const createUnsubscribeWrapperFunc = (observableId) => {\n        return () => {\n            const unsubFunc = connectedUnsubscribeMap.get(observableId);\n            if (unsubFunc) {\n                _logger('Unsubscribing.');\n                unsubFunc();\n                return;\n            }\n            _logger('Tried to unsubscribe, but subscription does not exist. This probably means unsubscribe has already been called for this subscription.');\n        };\n    };\n    return {\n        _subscribe,\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}