{"ast":null,"code":"/**\r\n *\r\n * server\r\n *\r\n */\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors } from './utils.mjs';\n/**\r\n * Makes a Protocol complient WebSocket GraphQL server. The server\r\n * is actually an API which is to be used with your favourite WebSocket\r\n * server library!\r\n *\r\n * Read more about the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\r\n *\r\n * @category Server\r\n */\nexport function makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate,\n    execute,\n    subscribe,\n    connectionInitWaitTimeout = 3000,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n        return async (code, reason) => {\n          /* nothing was set up, just notify the closure */\n          await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n        };\n      }\n      // kick the client off (close socket) if the connection has\n      // not been initialised after the specified wait timeout\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived) socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage(async function onMessage(data) {\n        var _a, e_1, _b, _c;\n        var _d;\n        let message;\n        try {\n          message = parseMessage(data, reviver);\n        } catch (err) {\n          return socket.close(CloseCode.BadRequest, 'Invalid message received');\n        }\n        switch (message.type) {\n          case MessageType.ConnectionInit:\n            {\n              if (ctx.connectionInitReceived) return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n              // @ts-expect-error: I can write\n              ctx.connectionInitReceived = true;\n              if (isObject(message.payload))\n                // @ts-expect-error: I can write\n                ctx.connectionParams = message.payload;\n              const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n              if (permittedOrPayload === false) return socket.close(CloseCode.Forbidden, 'Forbidden');\n              await socket.send(stringifyMessage(isObject(permittedOrPayload) ? {\n                type: MessageType.ConnectionAck,\n                payload: permittedOrPayload\n              } : {\n                type: MessageType.ConnectionAck\n                // payload is completely absent if not provided\n              }, replacer));\n              // @ts-expect-error: I can write\n              ctx.acknowledged = true;\n              return;\n            }\n          case MessageType.Ping:\n            {\n              if (socket.onPing)\n                // if the onPing listener is registered, automatic pong is disabled\n                return await socket.onPing(message.payload);\n              await socket.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong\n                // payload is completely absent if not provided\n              }));\n\n              return;\n            }\n          case MessageType.Pong:\n            return await ((_d = socket.onPong) === null || _d === void 0 ? void 0 : _d.call(socket, message.payload));\n          case MessageType.Subscribe:\n            {\n              if (!ctx.acknowledged) return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n              const {\n                id,\n                payload\n              } = message;\n              if (id in ctx.subscriptions) return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n              // if this turns out to be a streaming operation, the subscription value\n              // will change to an `AsyncIterable`, otherwise it will stay as is\n              ctx.subscriptions[id] = null;\n              const emit = {\n                next: async (result, args) => {\n                  let nextMessage = {\n                    id,\n                    type: MessageType.Next,\n                    payload: result\n                  };\n                  const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                  if (maybeResult) nextMessage = Object.assign(Object.assign({}, nextMessage), {\n                    payload: maybeResult\n                  });\n                  await socket.send(stringifyMessage(nextMessage, replacer));\n                },\n                error: async errors => {\n                  let errorMessage = {\n                    id,\n                    type: MessageType.Error,\n                    payload: errors\n                  };\n                  const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                  if (maybeErrors) errorMessage = Object.assign(Object.assign({}, errorMessage), {\n                    payload: maybeErrors\n                  });\n                  await socket.send(stringifyMessage(errorMessage, replacer));\n                },\n                complete: async notifyClient => {\n                  const completeMessage = {\n                    id,\n                    type: MessageType.Complete\n                  };\n                  await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                  if (notifyClient) await socket.send(stringifyMessage(completeMessage, replacer));\n                }\n              };\n              try {\n                let execArgs;\n                const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                if (maybeExecArgsOrErrors) {\n                  if (areGraphQLErrors(maybeExecArgsOrErrors)) return await emit.error(maybeExecArgsOrErrors);else if (Array.isArray(maybeExecArgsOrErrors)) throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                  // not errors, is exec args\n                  execArgs = maybeExecArgsOrErrors;\n                } else {\n                  // you either provide a schema dynamically through\n                  // `onSubscribe` or you set one up during the server setup\n                  if (!schema) throw new Error('The GraphQL schema is not provided');\n                  const args = {\n                    operationName: payload.operationName,\n                    document: parse(payload.query),\n                    variableValues: payload.variables\n                  };\n                  execArgs = Object.assign(Object.assign({}, args), {\n                    schema: typeof schema === 'function' ? await schema(ctx, message, args) : schema\n                  });\n                  const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                  if (validationErrors.length > 0) return await emit.error(validationErrors);\n                }\n                const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                if (!operationAST) return await emit.error([new GraphQLError('Unable to identify operation')]);\n                // if `onSubscribe` didnt specify a rootValue, inject one\n                if (!('rootValue' in execArgs)) execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                // if `onSubscribe` didn't specify a context, inject one\n                if (!('contextValue' in execArgs)) execArgs.contextValue = typeof context === 'function' ? await context(ctx, message, execArgs) : context;\n                // the execution arguments have been prepared\n                // perform the operation and act accordingly\n                let operationResult;\n                if (operationAST.operation === 'subscription') operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                // operation === 'query' || 'mutation'\n                else operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                if (maybeResult) operationResult = maybeResult;\n                if (isAsyncIterable(operationResult)) {\n                  /** multiple emitted results */\n                  if (!(id in ctx.subscriptions)) {\n                    // subscription was completed/canceled before the operation settled\n                    if (isAsyncGenerator(operationResult)) operationResult.return(undefined);\n                  } else {\n                    ctx.subscriptions[id] = operationResult;\n                    try {\n                      for (var _e = true, operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), _a = operationResult_1_1.done, !_a; _e = true) {\n                        _c = operationResult_1_1.value;\n                        _e = false;\n                        const result = _c;\n                        await emit.next(result, execArgs);\n                      }\n                    } catch (e_1_1) {\n                      e_1 = {\n                        error: e_1_1\n                      };\n                    } finally {\n                      try {\n                        if (!_e && !_a && (_b = operationResult_1.return)) await _b.call(operationResult_1);\n                      } finally {\n                        if (e_1) throw e_1.error;\n                      }\n                    }\n                  }\n                } else {\n                  /** single emitted result */\n                  // if the client completed the subscription before the single result\n                  // became available, he effectively canceled it and no data should be sent\n                  if (id in ctx.subscriptions) await emit.next(operationResult, execArgs);\n                }\n                // lack of subscription at this point indicates that the client\n                // completed the subscription, he doesnt need to be reminded\n                await emit.complete(id in ctx.subscriptions);\n              } finally {\n                // whatever happens to the subscription, we finally want to get rid of the reservation\n                delete ctx.subscriptions[id];\n              }\n              return;\n            }\n          case MessageType.Complete:\n            {\n              const subscription = ctx.subscriptions[message.id];\n              delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n              if (isAsyncGenerator(subscription)) await subscription.return(undefined);\n              return;\n            }\n          default:\n            throw new Error(`Unexpected message of type ${message.type} received`);\n        }\n      });\n      // wait for close, cleanup and the disconnect callback\n      return async (code, reason) => {\n        if (connectionInitWait) clearTimeout(connectionInitWait);\n        for (const sub of Object.values(ctx.subscriptions)) {\n          if (isAsyncGenerator(sub)) await sub.return(undefined);\n        }\n        if (ctx.acknowledged) await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n        await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n      };\n    }\n  };\n}\n/**\r\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\r\n * a set of WebSocket subprotocols.\r\n *\r\n * Accepts a set of already extracted WebSocket subprotocols or the raw\r\n * Sec-WebSocket-Protocol header value. In either case, if the right\r\n * protocol appears, it will be returned.\r\n *\r\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\r\n * if it does not agree with client's subprotocols. The client has a responsibility\r\n * to handle the connection afterwards.\r\n *\r\n * @category Server\r\n */\nexport function handleProtocols(protocols) {\n  switch (true) {\n    case protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case typeof protocols === 'string' && protocols.split(',').map(p => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","parse","validate","graphqlValidate","execute","graphqlExecute","subscribe","graphqlSubscribe","getOperationAST","GraphQLError","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","stringifyMessage","parseMessage","isObject","isAsyncGenerator","isAsyncIterable","areGraphQLErrors","makeServer","options","schema","context","roots","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","jsonMessageReviver","reviver","jsonMessageReplacer","replacer","opened","socket","extra","ctx","connectionInitReceived","acknowledged","subscriptions","protocol","close","SubprotocolNotAcceptable","code","reason","connectionInitWait","isFinite","setTimeout","ConnectionInitialisationTimeout","onMessage","data","_a","e_1","_b","_c","_d","message","err","BadRequest","type","ConnectionInit","TooManyInitialisationRequests","payload","connectionParams","permittedOrPayload","Forbidden","send","ConnectionAck","Ping","onPing","Pong","onPong","Subscribe","Unauthorized","id","SubscriberAlreadyExists","emit","next","result","args","nextMessage","Next","maybeResult","Object","assign","error","errors","errorMessage","Error","maybeErrors","complete","notifyClient","completeMessage","Complete","execArgs","maybeExecArgsOrErrors","Array","isArray","operationName","document","query","variableValues","variables","validationErrors","length","operationAST","rootValue","operation","contextValue","operationResult","return","undefined","_e","operationResult_1","operationResult_1_1","e_1_1","subscription","clearTimeout","sub","values","handleProtocols","protocols","Set","has","includes","split","map","p","trim"],"sources":["C:/Users/mabur/Desktop/College/SacState/CSC131/MainProject/BeamTeamCSC131/node_modules/graphql-ws/lib/server.mjs"],"sourcesContent":["/**\r\n *\r\n * server\r\n *\r\n */\r\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n};\r\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError, } from 'graphql';\r\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage, } from './common.mjs';\r\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors, } from './utils.mjs';\r\n/**\r\n * Makes a Protocol complient WebSocket GraphQL server. The server\r\n * is actually an API which is to be used with your favourite WebSocket\r\n * server library!\r\n *\r\n * Read more about the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\r\n *\r\n * @category Server\r\n */\r\nexport function makeServer(options) {\r\n    const { schema, context, roots, validate, execute, subscribe, connectionInitWaitTimeout = 3000, // 3 seconds\r\n    onConnect, onDisconnect, onClose, onSubscribe, onOperation, onNext, onError, onComplete, jsonMessageReviver: reviver, jsonMessageReplacer: replacer, } = options;\r\n    return {\r\n        opened(socket, extra) {\r\n            const ctx = {\r\n                connectionInitReceived: false,\r\n                acknowledged: false,\r\n                subscriptions: {},\r\n                extra,\r\n            };\r\n            if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\r\n                socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\r\n                return async (code, reason) => {\r\n                    /* nothing was set up, just notify the closure */\r\n                    await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\r\n                };\r\n            }\r\n            // kick the client off (close socket) if the connection has\r\n            // not been initialised after the specified wait timeout\r\n            const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout)\r\n                ? setTimeout(() => {\r\n                    if (!ctx.connectionInitReceived)\r\n                        socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\r\n                }, connectionInitWaitTimeout)\r\n                : null;\r\n            socket.onMessage(async function onMessage(data) {\r\n                var _a, e_1, _b, _c;\r\n                var _d;\r\n                let message;\r\n                try {\r\n                    message = parseMessage(data, reviver);\r\n                }\r\n                catch (err) {\r\n                    return socket.close(CloseCode.BadRequest, 'Invalid message received');\r\n                }\r\n                switch (message.type) {\r\n                    case MessageType.ConnectionInit: {\r\n                        if (ctx.connectionInitReceived)\r\n                            return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\r\n                        // @ts-expect-error: I can write\r\n                        ctx.connectionInitReceived = true;\r\n                        if (isObject(message.payload))\r\n                            // @ts-expect-error: I can write\r\n                            ctx.connectionParams = message.payload;\r\n                        const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\r\n                        if (permittedOrPayload === false)\r\n                            return socket.close(CloseCode.Forbidden, 'Forbidden');\r\n                        await socket.send(stringifyMessage(isObject(permittedOrPayload)\r\n                            ? {\r\n                                type: MessageType.ConnectionAck,\r\n                                payload: permittedOrPayload,\r\n                            }\r\n                            : {\r\n                                type: MessageType.ConnectionAck,\r\n                                // payload is completely absent if not provided\r\n                            }, replacer));\r\n                        // @ts-expect-error: I can write\r\n                        ctx.acknowledged = true;\r\n                        return;\r\n                    }\r\n                    case MessageType.Ping: {\r\n                        if (socket.onPing)\r\n                            // if the onPing listener is registered, automatic pong is disabled\r\n                            return await socket.onPing(message.payload);\r\n                        await socket.send(stringifyMessage(message.payload\r\n                            ? { type: MessageType.Pong, payload: message.payload }\r\n                            : {\r\n                                type: MessageType.Pong,\r\n                                // payload is completely absent if not provided\r\n                            }));\r\n                        return;\r\n                    }\r\n                    case MessageType.Pong:\r\n                        return await ((_d = socket.onPong) === null || _d === void 0 ? void 0 : _d.call(socket, message.payload));\r\n                    case MessageType.Subscribe: {\r\n                        if (!ctx.acknowledged)\r\n                            return socket.close(CloseCode.Unauthorized, 'Unauthorized');\r\n                        const { id, payload } = message;\r\n                        if (id in ctx.subscriptions)\r\n                            return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\r\n                        // if this turns out to be a streaming operation, the subscription value\r\n                        // will change to an `AsyncIterable`, otherwise it will stay as is\r\n                        ctx.subscriptions[id] = null;\r\n                        const emit = {\r\n                            next: async (result, args) => {\r\n                                let nextMessage = {\r\n                                    id,\r\n                                    type: MessageType.Next,\r\n                                    payload: result,\r\n                                };\r\n                                const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\r\n                                if (maybeResult)\r\n                                    nextMessage = Object.assign(Object.assign({}, nextMessage), { payload: maybeResult });\r\n                                await socket.send(stringifyMessage(nextMessage, replacer));\r\n                            },\r\n                            error: async (errors) => {\r\n                                let errorMessage = {\r\n                                    id,\r\n                                    type: MessageType.Error,\r\n                                    payload: errors,\r\n                                };\r\n                                const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\r\n                                if (maybeErrors)\r\n                                    errorMessage = Object.assign(Object.assign({}, errorMessage), { payload: maybeErrors });\r\n                                await socket.send(stringifyMessage(errorMessage, replacer));\r\n                            },\r\n                            complete: async (notifyClient) => {\r\n                                const completeMessage = {\r\n                                    id,\r\n                                    type: MessageType.Complete,\r\n                                };\r\n                                await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\r\n                                if (notifyClient)\r\n                                    await socket.send(stringifyMessage(completeMessage, replacer));\r\n                            },\r\n                        };\r\n                        try {\r\n                            let execArgs;\r\n                            const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\r\n                            if (maybeExecArgsOrErrors) {\r\n                                if (areGraphQLErrors(maybeExecArgsOrErrors))\r\n                                    return await emit.error(maybeExecArgsOrErrors);\r\n                                else if (Array.isArray(maybeExecArgsOrErrors))\r\n                                    throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\r\n                                // not errors, is exec args\r\n                                execArgs = maybeExecArgsOrErrors;\r\n                            }\r\n                            else {\r\n                                // you either provide a schema dynamically through\r\n                                // `onSubscribe` or you set one up during the server setup\r\n                                if (!schema)\r\n                                    throw new Error('The GraphQL schema is not provided');\r\n                                const args = {\r\n                                    operationName: payload.operationName,\r\n                                    document: parse(payload.query),\r\n                                    variableValues: payload.variables,\r\n                                };\r\n                                execArgs = Object.assign(Object.assign({}, args), { schema: typeof schema === 'function'\r\n                                        ? await schema(ctx, message, args)\r\n                                        : schema });\r\n                                const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\r\n                                if (validationErrors.length > 0)\r\n                                    return await emit.error(validationErrors);\r\n                            }\r\n                            const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\r\n                            if (!operationAST)\r\n                                return await emit.error([\r\n                                    new GraphQLError('Unable to identify operation'),\r\n                                ]);\r\n                            // if `onSubscribe` didnt specify a rootValue, inject one\r\n                            if (!('rootValue' in execArgs))\r\n                                execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\r\n                            // if `onSubscribe` didn't specify a context, inject one\r\n                            if (!('contextValue' in execArgs))\r\n                                execArgs.contextValue =\r\n                                    typeof context === 'function'\r\n                                        ? await context(ctx, message, execArgs)\r\n                                        : context;\r\n                            // the execution arguments have been prepared\r\n                            // perform the operation and act accordingly\r\n                            let operationResult;\r\n                            if (operationAST.operation === 'subscription')\r\n                                operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\r\n                            // operation === 'query' || 'mutation'\r\n                            else\r\n                                operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\r\n                            const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\r\n                            if (maybeResult)\r\n                                operationResult = maybeResult;\r\n                            if (isAsyncIterable(operationResult)) {\r\n                                /** multiple emitted results */\r\n                                if (!(id in ctx.subscriptions)) {\r\n                                    // subscription was completed/canceled before the operation settled\r\n                                    if (isAsyncGenerator(operationResult))\r\n                                        operationResult.return(undefined);\r\n                                }\r\n                                else {\r\n                                    ctx.subscriptions[id] = operationResult;\r\n                                    try {\r\n                                        for (var _e = true, operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), _a = operationResult_1_1.done, !_a; _e = true) {\r\n                                            _c = operationResult_1_1.value;\r\n                                            _e = false;\r\n                                            const result = _c;\r\n                                            await emit.next(result, execArgs);\r\n                                        }\r\n                                    }\r\n                                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                                    finally {\r\n                                        try {\r\n                                            if (!_e && !_a && (_b = operationResult_1.return)) await _b.call(operationResult_1);\r\n                                        }\r\n                                        finally { if (e_1) throw e_1.error; }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                /** single emitted result */\r\n                                // if the client completed the subscription before the single result\r\n                                // became available, he effectively canceled it and no data should be sent\r\n                                if (id in ctx.subscriptions)\r\n                                    await emit.next(operationResult, execArgs);\r\n                            }\r\n                            // lack of subscription at this point indicates that the client\r\n                            // completed the subscription, he doesnt need to be reminded\r\n                            await emit.complete(id in ctx.subscriptions);\r\n                        }\r\n                        finally {\r\n                            // whatever happens to the subscription, we finally want to get rid of the reservation\r\n                            delete ctx.subscriptions[id];\r\n                        }\r\n                        return;\r\n                    }\r\n                    case MessageType.Complete: {\r\n                        const subscription = ctx.subscriptions[message.id];\r\n                        delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\r\n                        if (isAsyncGenerator(subscription))\r\n                            await subscription.return(undefined);\r\n                        return;\r\n                    }\r\n                    default:\r\n                        throw new Error(`Unexpected message of type ${message.type} received`);\r\n                }\r\n            });\r\n            // wait for close, cleanup and the disconnect callback\r\n            return async (code, reason) => {\r\n                if (connectionInitWait)\r\n                    clearTimeout(connectionInitWait);\r\n                for (const sub of Object.values(ctx.subscriptions)) {\r\n                    if (isAsyncGenerator(sub))\r\n                        await sub.return(undefined);\r\n                }\r\n                if (ctx.acknowledged)\r\n                    await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\r\n                await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\r\n            };\r\n        },\r\n    };\r\n}\r\n/**\r\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\r\n * a set of WebSocket subprotocols.\r\n *\r\n * Accepts a set of already extracted WebSocket subprotocols or the raw\r\n * Sec-WebSocket-Protocol header value. In either case, if the right\r\n * protocol appears, it will be returned.\r\n *\r\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\r\n * if it does not agree with client's subprotocols. The client has a responsibility\r\n * to handle the connection afterwards.\r\n *\r\n * @category Server\r\n */\r\nexport function handleProtocols(protocols) {\r\n    switch (true) {\r\n        case protocols instanceof Set &&\r\n            protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\r\n        case Array.isArray(protocols) &&\r\n            protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\r\n        case typeof protocols === 'string' &&\r\n            protocols\r\n                .split(',')\r\n                .map((p) => p.trim())\r\n                .includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\r\n            return GRAPHQL_TRANSPORT_WS_PROTOCOL;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}