{"ast":null,"code":"import { v4 as uuid4 } from '@lukeed/uuid';\nimport { print } from 'graphql';\nimport { createClient } from 'graphql-ws';\nimport WebSocket from 'isomorphic-ws';\n// Extends core client with subscriptions\nexport const createSubscriptionClient = function (options, {\n  _logger,\n  _onAuthStateChange\n}) {\n  const {\n    apiKey,\n    getCredentials,\n    onError\n  } = options;\n  let subscriptionClient;\n  const _createSubscriptionClient = () => {\n    _logger('Creating subscription client...');\n    let websocketUrl = options.websocketUrl ?? '';\n    // Just in case user adds trailing slash\n    if (websocketUrl.endsWith('/')) {\n      websocketUrl = websocketUrl.slice(0, -1);\n    }\n    const subClientOptions = {\n      url: websocketUrl,\n      webSocketImpl: WebSocket\n    };\n    // If user provides getCredentials, pass that to connectionParams\n    if (typeof getCredentials === 'function') {\n      // This will be called for every connection_init event and the payload will contain { token: <user's jwt> OR apiKey: <apiKey> }\n      subClientOptions.connectionParams = async () => {\n        const credentials = await getCredentials();\n        return {\n          ...credentials\n        };\n      };\n    } else if (apiKey) {\n      // If they initialized client with apiKey just pass in static object\n      subClientOptions.connectionParams = {\n        apiKey\n      };\n    }\n    const subClient = createClient(subClientOptions);\n    subClient.on('connecting', () => _logger('subscriptionClient connecting...'));\n    subClient.on('connected', () => _logger('subscriptionClient connected!'));\n    subClient.on('closed', () => _logger('subscriptionClient ---disconnected!!!---'));\n    return subClient;\n  };\n  /*\r\n    Because we may not have the observable's raw unsubscribe function available to return to user\r\n    when they create a subscribtion, we return a proxy \"wrapper\" function that will look-up the real unsub func from connectedUnsubscribeMap when called.\r\n  */\n  const connectedUnsubscribeMap = new Map();\n  const _subscribe = ({\n    query,\n    variables\n  }, handler) => {\n    const queryAsString = print(query);\n    _logger(`subscriptionClient creating subscription ${queryAsString}`);\n    if (options.websocketUrl === undefined) {\n      throw new Error('Please initialize @vendia/client with the websocketUrl option in order to use subscriptions.');\n    }\n    // Don't create a socket connection until user tries to use subscription\n    if (subscriptionClient === undefined) {\n      subscriptionClient = _createSubscriptionClient();\n    }\n    const unsubscribe = subscriptionClient.subscribe({\n      query: queryAsString,\n      variables\n    }, {\n      next: handler,\n      error: error => {\n        _logger('subscriptionClient error:', JSON.stringify(error, null, 2));\n        if (typeof onError === 'function') {\n          onError(error);\n        }\n      },\n      complete: () => {\n        _logger('subscriptionClient complete fired');\n      }\n    });\n    const observableId = uuid4();\n    connectedUnsubscribeMap.set(observableId, unsubscribe);\n    return createUnsubscribeWrapperFunc(observableId);\n  };\n  const createUnsubscribeWrapperFunc = observableId => {\n    return () => {\n      const unsubFunc = connectedUnsubscribeMap.get(observableId);\n      if (unsubFunc) {\n        _logger('Unsubscribing.');\n        unsubFunc();\n        return;\n      }\n      _logger('Tried to unsubscribe, but subscription does not exist. This probably means unsubscribe has already been called for this subscription.');\n    };\n  };\n  return {\n    _subscribe\n  };\n};","map":{"version":3,"names":["v4","uuid4","print","createClient","WebSocket","createSubscriptionClient","options","_logger","_onAuthStateChange","apiKey","getCredentials","onError","subscriptionClient","_createSubscriptionClient","websocketUrl","endsWith","slice","subClientOptions","url","webSocketImpl","connectionParams","credentials","subClient","on","connectedUnsubscribeMap","Map","_subscribe","query","variables","handler","queryAsString","undefined","Error","unsubscribe","subscribe","next","error","JSON","stringify","complete","observableId","set","createUnsubscribeWrapperFunc","unsubFunc","get"],"sources":["C:/Users/mabur/Desktop/College/SacState/CSC131/MainRepo6/BeamTeamCSC131/node_modules/.vendia-client/esm/create-subscription-client.js"],"sourcesContent":["import { v4 as uuid4 } from '@lukeed/uuid';\r\nimport { print } from 'graphql';\r\nimport { createClient } from 'graphql-ws';\r\nimport WebSocket from 'isomorphic-ws';\r\n// Extends core client with subscriptions\r\nexport const createSubscriptionClient = function (options, { _logger, _onAuthStateChange, }) {\r\n    const { apiKey, getCredentials, onError } = options;\r\n    let subscriptionClient;\r\n    const _createSubscriptionClient = () => {\r\n        _logger('Creating subscription client...');\r\n        let websocketUrl = options.websocketUrl ?? '';\r\n        // Just in case user adds trailing slash\r\n        if (websocketUrl.endsWith('/')) {\r\n            websocketUrl = websocketUrl.slice(0, -1);\r\n        }\r\n        const subClientOptions = {\r\n            url: websocketUrl,\r\n            webSocketImpl: WebSocket,\r\n        };\r\n        // If user provides getCredentials, pass that to connectionParams\r\n        if (typeof getCredentials === 'function') {\r\n            // This will be called for every connection_init event and the payload will contain { token: <user's jwt> OR apiKey: <apiKey> }\r\n            subClientOptions.connectionParams = async () => {\r\n                const credentials = await getCredentials();\r\n                return {\r\n                    ...credentials,\r\n                };\r\n            };\r\n        }\r\n        else if (apiKey) {\r\n            // If they initialized client with apiKey just pass in static object\r\n            subClientOptions.connectionParams = { apiKey };\r\n        }\r\n        const subClient = createClient(subClientOptions);\r\n        subClient.on('connecting', () => _logger('subscriptionClient connecting...'));\r\n        subClient.on('connected', () => _logger('subscriptionClient connected!'));\r\n        subClient.on('closed', () => _logger('subscriptionClient ---disconnected!!!---'));\r\n        return subClient;\r\n    };\r\n    /*\r\n      Because we may not have the observable's raw unsubscribe function available to return to user\r\n      when they create a subscribtion, we return a proxy \"wrapper\" function that will look-up the real unsub func from connectedUnsubscribeMap when called.\r\n    */\r\n    const connectedUnsubscribeMap = new Map();\r\n    const _subscribe = ({ query, variables }, handler) => {\r\n        const queryAsString = print(query);\r\n        _logger(`subscriptionClient creating subscription ${queryAsString}`);\r\n        if (options.websocketUrl === undefined) {\r\n            throw new Error('Please initialize @vendia/client with the websocketUrl option in order to use subscriptions.');\r\n        }\r\n        // Don't create a socket connection until user tries to use subscription\r\n        if (subscriptionClient === undefined) {\r\n            subscriptionClient = _createSubscriptionClient();\r\n        }\r\n        const unsubscribe = subscriptionClient.subscribe({ query: queryAsString, variables }, {\r\n            next: handler,\r\n            error: (error) => {\r\n                _logger('subscriptionClient error:', JSON.stringify(error, null, 2));\r\n                if (typeof onError === 'function') {\r\n                    onError(error);\r\n                }\r\n            },\r\n            complete: () => {\r\n                _logger('subscriptionClient complete fired');\r\n            },\r\n        });\r\n        const observableId = uuid4();\r\n        connectedUnsubscribeMap.set(observableId, unsubscribe);\r\n        return createUnsubscribeWrapperFunc(observableId);\r\n    };\r\n    const createUnsubscribeWrapperFunc = (observableId) => {\r\n        return () => {\r\n            const unsubFunc = connectedUnsubscribeMap.get(observableId);\r\n            if (unsubFunc) {\r\n                _logger('Unsubscribing.');\r\n                unsubFunc();\r\n                return;\r\n            }\r\n            _logger('Tried to unsubscribe, but subscription does not exist. This probably means unsubscribe has already been called for this subscription.');\r\n        };\r\n    };\r\n    return {\r\n        _subscribe,\r\n    };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}